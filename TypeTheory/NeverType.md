# Never Type

**Never type** — это тип, не имеющий ни одного значения, то есть по сути является
пустым множеством. В язык программирования используется для обозначения невозможности 
вычисления (его завершения) и зачастую является [bottom-типом](https://en.wikipedia.org/wiki/Bottom_type). 

## Примеры использования 

### Базовый пример

Например, у нас есть функция `exit`, что завершает исполнения нашей программы, 
то есть функция никогда не завершится! Вот реальная сигнатура `std::process::exit` 
из стандартной библиотеке Rust[^neverust]'а:
```rust
pub fn exit(code: i32) -> !
```
* `!` - литерал never-типа


### Инвариант типов

```rust
fn main() -> Result<!, ExitCode> {
  // ...
}
```

## Альтернативы 

В Haskell в качестве never-типа используется `Void`, определенный как тип без конструктора:
```hs
data Void
```
Язык также поддерживает создание пользовательских пустых типов.
Стоит заметить, что в присутствии побочных эффектов нетерминированный терм не обязательно является пустым.
Так, например, сигнатура функции `exit` в стандартной библиотеке Haskell'я выглядит так:
```haskell
exitWith :: ExitCode -> IO a
```
* `a` - переменная типа 
За счет того, что этот терм в действительности не является пустым.

Однако, результат вычисления этого терма с побочными эффектами является пустым.
То есть ни одна программа, использующая результат вычисления этого терма никогда не будет выполнена.
Здесь, вместо `Void` используется аналогичный с точки зрения теории типов пустой тип - `forall a. a`.
Доказать, что он пуст несложно. Для этого достаточно подставить `Void` вместо переменной типа `a`:
```hs
exitWith @Void :: ExitCode -> IO Void
```

## Ссылки 

* StackOverflow [Why does Rust have a "Never" primitive type?](https://stackoverflow.com/a/51835567)
* [Rust never type](https://doc.rust-lang.org/stable/std/primitive.never.html)
* Хабр ["TypeScript. Мощь never"](https://habr.com/ru/articles/471026/)

---
[^neverust]: На момент весны 2023 года, `rustc 1.69.0`, never type в Rust не является first-class типом, то есть его нельзя использовать в композиции с другими типами. Например: `Result<!, E>`. Однако, это верно только для стабильной версии компилятора, так как nightly имеют экспериментальную поддержку.   
